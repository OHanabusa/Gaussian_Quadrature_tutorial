# ガウス求積による数値積分チュートリアル

このチュートリアルでは、**ガウス求積 (Gaussian Quadrature)** を用いて定積分を数値的に計算する方法を、理論の解説、Python実装、および簡単な演習を通して学びます。積分の精度を高めるためには、積分点（ガウス点）の選び方と重みの設定が非常に重要です。本チュートリアルでは、なぜそのような点や重みを選ぶのかといった背景も含めて丁寧に解説していきます。

---

## 📘 目次

1. [背景と動機](#背景と動機)
2. [ガウス求積の理論](#ガウス求積の理論)
3. [Pythonによる実装](#pythonによる実装)
4. [次数ごとのガウス点と重み](#次数ごとのガウス点と重み)
5. [具体例](#具体例)
6. [演習問題](#演習問題)
7. [参考文献](#参考文献)

---

## 背景と動機

数値積分は、解析的に積分できない関数や、離散的なデータから積分値を求めたい場合に有効な手法です。台形則やSimpson則などの古典的な手法に比べて、ガウス求積は少ない点数でも非常に高い精度を達成することができます。

特に、関数が滑らかである場合、ガウス求積は他の数値積分法よりも高速かつ正確に積分値を求めることが可能です。このため、ガウス求積法は数値解析、計算物理学、工学、特に有限要素法（FEM）などの応用分野において標準的な手法となっています。

---

## ガウス求積の理論

### 基本アイデア

ガウス求積法では、積分区間を \([-1, 1]\) に固定し、その範囲での積分を最適な点と重みに基づいて近似します：

$$
\int_{-1}^{1} f(x)\, dx \approx \sum_{i=1}^{n} w_i f(x_i)
$$

この近似が非常に高精度なのは、
- 積分点 \(x_i\) が **Legendre多項式の零点** であり、
- 重み \(w_i\) が誤差を最小にするように最適化されている
ためです。

このアプローチの利点は、\(2n-1\) 次までの多項式については誤差が理論的にゼロになることです。

### 一般の区間への変換

通常、積分したい関数の定義域は \([a, b]\) など任意の区間であるため、ガウス求積法を使うためには標準区間 \([-1, 1]\) に変換する必要があります。これには線形変換を用います：

$$
\int_{a}^{b} f(x) dx = \frac{b-a}{2} \int_{-1}^{1} f\left(\frac{b-a}{2}x + \frac{a+b}{2}\right) dx
$$

この変換により、任意の区間の積分問題も \([-1, 1]\) の範囲に引き戻して計算できるようになり、汎用性が高まります。

---

## Pythonによる実装

ここでは、外部モジュールを使わずに簡単な2点ガウス求積（\(n=2\)）を実装します。

```python
# 2点ガウス求積用のガウス点と重み
x_list = [-0.5773502692, 0.5773502692]  # Legendre多項式の零点（精度2）
w_list = [1.0, 1.0]  # 対応する重み

def gauss_quadrature_2pt(f, a, b):
    total = 0.0
    for i in range(2):
        # 変数変換： [-1, 1] -> [a, b]
        xi = x_list[i]
        wi = w_list[i]
        x_trans = 0.5 * (b - a) * xi + 0.5 * (a + b)
        total += wi * f(x_trans)
    return 0.5 * (b - a) * total
```

### 各ステップの解説
- `x_list` と `w_list` は Legendre 多項式の零点と重みを手動で設定。
- `x_trans` は変数変換によって、\([-1,1]\) の点を \([a,b]\) に移し替えたもの。
- 各点で関数 \(f(x)\) の値を計算し、重みを掛けて合計します。
- 最終的な積分値は、区間のスケーリング係数 \(\frac{b-a}{2}\) をかけて調整されます。

このようにすることで、標準化されたガウス点を再利用しながら、任意の区間にわたる積分を高精度に計算できます。

---

## 次数ごとのガウス点と重み

以下は、いくつかの次数に対応するガウス点 \(x_i\) と重み \(w_i\) の一覧です。

この一覧は、必要な精度に応じてどの程度の点数を使えばよいか判断する際の参考になります。

### \(n = 2\)
| \(x_i\)               | \(w_i\) |
|----------------------|---------|
| \(-0.5773502692\)     | 1.0000000000 |
| \(+0.5773502692\)     | 1.0000000000 |

### \(n = 3\)
| \(x_i\)               | \(w_i\) |
|----------------------|---------|
| \(-0.7745966692\)     | 0.5555555556 |
| \( 0.0000000000\)     | 0.8888888889 |
| \(+0.7745966692\)     | 0.5555555556 |

### \(n = 4\)
| \(x_i\)               | \(w_i\) |
|----------------------|---------|
| \(-0.8611363116\)     | 0.3478548451 |
| \(-0.3399810436\)     | 0.6521451549 |
| \(+0.3399810436\)     | 0.6521451549 |
| \(+0.8611363116\)     | 0.3478548451 |

### \(n = 5\)
| \(x_i\)               | \(w_i\) |
|----------------------|---------|
| \(-0.9061798459\)     | 0.2369268851 |
| \(-0.5384693101\)     | 0.4786286705 |
| \( 0.0000000000\)     | 0.5688888889 |
| \(+0.5384693101\)     | 0.4786286705 |
| \(+0.9061798459\)     | 0.2369268851 |

（参考：Wikipedia - Gaussian Quadrature）

---

## 具体例

次の積分を計算します：

$$
\int_0^1 e^{-x^2} dx
$$

この関数はガウス積分（エラーファンクション）として知られ、解析的な閉形式での表現が難しいため、数値的に近似することが一般的です。

```python
from math import exp

result = gauss_quadrature_2pt(lambda x: exp(-x**2), 0, 1)
print(f"Approximate integral: {result:.8f}")
```

実行すると、数値積分の有効性とガウス求積の高精度が確認できます。

---

## 演習問題

1. $$\int_0^\pi \sin(x) dx$$ を2点ガウス求積で計算せよ。
   - 正解は 2 です。得られた結果と比較して誤差を評価してください。

2. $$\int_0^2 x^3 - x + 1 dx$$ を解析解と比較せよ。
   - 関数が多項式であるため、理論上、十分な点数を用いれば誤差ゼロになります。

3. 精度と点数 $$n$$ の関係を調べよ（n=2〜10）※高次の点と重みは自分で与えてください。
   - 各点数に対して誤差を計算し、グラフ化してもよいでしょう。

4. 2次元ガウス求積を使って $$\int_0^1 \int_0^1 e^{-(x^2 + y^2)} dxdy$$ を実装せよ。
   - x方向とy方向の積分を入れ子にして、2重ループで処理できます。

---

## 参考文献

- Quarteroni, A., et al. "Numerical Mathematics." Springer.
- Burden, R. L., and Faires, J. D. "Numerical Analysis."
- ガウス点と重みに関する表： [Wikipedia - Gaussian Quadrature](https://en.wikipedia.org/wiki/Gaussian_quadrature)

