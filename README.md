# ガウス求積入門 — 実装のための基礎から一般区間への拡張

---

## 導入 — なぜ数値積分を学ぶのか？

- **解析解が得られない積分が多い**\
  複雑な関数、実測データ、確率分布の畳み込みなどは閉形式の積分解を持ちません。
- **実装必須のアルゴリズムが増えている**\
  有限要素法 (FEM)、確率シミュレーション、機械学習の期待値計算、物理ベースレンダリングなど、プログラム内で“積分器”を自作する場面が多々あります。
- **ガウス求積は少点数で高精度**\
  同じ精度を得るのに台形則や Simpson 則より格段に少ない評価回数で済み、計算コストを抑えられます。

> **目的**：ガウス求積公式と係数表を提示し、任意区間に拡張する手順、および実装演習までを体系的にまとめます。

---

## 1.1 基本式

$$
\int_{-1}^{1} f(x) dx  \approx  \sum_{i=1}^{n} w_i f(x_i) \qquad (1)
$$

**式 (1) の意味**：左辺は区間 \([-1,1]\) の正確な積分値、右辺は **有限個 ****\(n\)**** 個の点での関数評価** と **重み付き和** によって近似したものです。ガウス点 \(x_i\) と重み \(w_i\) は「Legendre 多項式の零点」と「その零点に対して誤差が最小となる係数」として選ばれており、\(2n-1\) 次までの多項式については誤差が理論的にゼロになります。

| \(n\) | ガウス点 \(x_i\)                              | 重み \(w_i\)                                              |
| ----- | ----------------------------------------- | ------------------------------------------------------- |
| 2     | \(\pm0.5773502692\)                       | 1.0000000000                                            |
| 3     | \(\pm0.7745966692, 0\)                   | 0.5555555556 (両端), 0.8888888889 (中央)                    |
| 4     | \(\pm0.8611363116, \pm0.3399810436\)     | 0.3478548451 (外側), 0.6521451549 (内側)                    |
| 5     | \(\pm0.9061798459, \pm0.5384693101, 0\) | 0.2369268851 (最外), 0.4786286705 (中間), 0.5688888889 (中央) |

---

## 2.0 何をしたいのか？

ガウス求積は標準区間 \([-1,1]\) に対して定義されています。しかし、実務では **任意の有限区間 ****\([x_1,x_2]\)** の積分を評価することが一般的です。この章では「区間変換」と「ヤコビアン補正」により、式 (1) をそのまま他区間へ適用できる形に一般化します。

## 2.1 変数変換

$$
\xi \in [-1,1], \qquad x(\xi)=\frac{x_2-x_1}{2} \xi + \frac{x_1+x_2}{2}. \qquad(2)
$$

**式 (2) の意味**：パラメータ \(\xi\) を用いて線形写像を定義し、標準区間 \([-1,1]\) の任意点 \(\xi\) を区間 \([x_1,x_2]\) の点 \(x\) へマッピングします。

## 2.2 ヤコビアン

$$
\frac{dx}{d\xi}=\frac{x_2-x_1}{2}=J. \qquad(3)
$$

**式 (3) の意味**：変数変換で生じる区間の伸縮を補正するスケール係数（ヤコビアン）です。

## 2.3 一般区間でのガウス求積公式

$$
\boxed{\displaystyle
\int_{x_1}^{x_2} f(x) dx  \approx  J \sum_{i=1}^{n} w_i f\!\left( \frac{x_2-x_1}{2} \xi_i+\frac{x_1+x_2}{2} \right)
}\qquad (4)
$$

**式 (4) の意味**：標準区間で得たガウス点・重みをそのまま再利用できる形に拡張した公式です。外側の \(J\) がスケール、内部が変換後の評価点を表します。

---

# 3章 │ Python 実装テンプレート（多点数対応・任意区間）

```python
# === Gauss-Legendre データ: n 点数 → (ガウス点リスト, 重みリスト) ===
gauss_data = {
    2: ([-0.577350269189626, 0.577350269189626], [1.0, 1.0]),
    3: ([-0.774596669241483, 0.0, 0.774596669241483],
        [0.555555555555556, 0.888888888888889, 0.555555555555556]),
    4: ([-0.861136311594053, -0.339981043584856,
          0.339981043584856,  0.861136311594053],
        [0.347854845137454, 0.652145154862546,
         0.652145154862546, 0.347854845137454]),
    5: ([-0.906179845938664, -0.538469310105683, 0.0,
          0.538469310105683,  0.906179845938664],
        [0.236926885056189, 0.478628670499366, 0.568888888888889,
         0.478628670499366, 0.236926885056189]),
}

def gauss_interval(f, a, b, n=2):
    """[a,b] 区間の n 点ガウス求積 (n=2〜5) — ★★ 空欄を埋めて完成させよう ★★"""
    # 1) ガウス点と重みを取得
    xg, wg = gauss_data[n]

    # 2) ヤコビアン J を計算  ↓↓↓
    J = ...  # TODO: ここを計算式に置き換え

    # 3) 区間中心 c  を計算  ↓↓↓
    c = ...  # TODO: ここを計算式に置き換え

    # 4) 積分値を格納する変数を初期化
    s = 0.0

    # 5) ガウス点ごとにループして重み付き評価値を加算
    for xi, wi in zip(xg, wg):
        x = ...  # TODO: 変換後の評価点 
        s += ...  # TODO: 重みをかけて加算 

    # 6) 最後にヤコビアン J を掛けて返す
    return ...  # TODO: 
```

> **埋め方ガイド**
>
> 1. `J` は `0.5 * (b - a)`
> 2. `c` は `0.5 * (a + b)`
> 3. 変換後の評価点は `x = J * xi + c`
> 4. ループ内で `s += wi * f(x)`
> 5. 関数の戻り値は `J * s`\
>    これら 5 カ所を **TODO** 行に記述すれば完成します。

> **使い方**：`n` に 2〜5 を指定して任意点数を選択可。

---

### 3.1 サンプル計算例

被積分関数:

$$
f(x) = 2x^2 + 3x + 1
$$

解析積分:

$$
\int_{0}^{2} (2x^2 + 3x + 1) dx = \left[\frac{2}{3}x^3 + \frac{3}{2}x^2 + x\right]_{0}^{2} = \frac{40}{3} \approx 13.333333333
$$

```python
f = lambda x: 2*x**2 + 3*x + 1
approx = gauss_interval(f, 0, 2, n=2)
print(approx)  # -> 13.333333333333334
```

解析値 \(=40/3\) と一致し、誤差ゼロを確認。

---

## 3.2 演習問題（解答付き）

| # | 被積分関数             | 区間        | 指示                                                                      | 正しい積分値                              |
| - | ----------------- | --------- | ----------------------------------------------------------------------- | ----------------------------------- |
| 1 | \(2x^2 + 3x + 1\) | \([1,3]\) | **2点** ガウス求積で実装                                                         | 31.333333333 |
| 2 | \(\sin(3x)\)      | \([0,1]\) | **テーラー展開 3 次まで**　を用い **2点** で計算 | 0.375                               |
| 3 | \(x^4 - x^2 + 1\) | \([0,2]\) | **3点** ガウス求積を用いる                                                        | 5.733333333                         |

> **ヒント**：問3は \(n=3\) を `gauss_interval` に渡して解くこと。

---

# 4章 │ 2変数ガウス求積法の導出

数値積分を 2 変数関数に拡張するため、まず物理空間と参照空間の座標系を定義し、一次写像とヤコビアン行列を導入します。最後に、一般的な 2 重積分からガウス求積の形に至るまでをステップ・バイ・ステップで示します。

---



## 4.1 座標の定義とヤコビアン行列

- **物理空間の座標**  
![image](https://github.com/user-attachments/assets/d1cea7d3-2b0d-4109-8ef1-5c9d0aeaf4eb)


- **参照空間（パラメータ空間）の座標**  
![image](https://github.com/user-attachments/assets/eeee38fc-45e2-4e1b-b0d8-1f161ea55b3a)


参照空間から物理空間への線形写像を

![image](https://github.com/user-attachments/assets/b2bd1c28-39f6-4d9a-a128-94384c60ec70)


として定義します。ここで

![image](https://github.com/user-attachments/assets/cb9dd250-ed06-4933-a4b4-fc418a28e280)

![image](https://github.com/user-attachments/assets/b006d14a-a81b-4eda-9712-30cb7a8f13ce)

**解説**：  
- 行列 **J** の対角要素が 𝜉・𝜂 方向のスケール変換を担い、  
- ベクトル **c** が領域の中心位置を表します。

---

## 4.2 2重積分の一般形

物理空間の 2 重積分は、

![image](https://github.com/user-attachments/assets/ae18f707-290a-45d2-8371-fc2ce10b454b)


**解説**：  
\( dy dx\) は物理空間の面積要素です。

---

## 4.3 変数変換とヤコビアンの導入

参照空間の面積要素を dξ dη とすると、

![image](https://github.com/user-attachments/assets/76c38997-08dd-48a3-8b79-530819634c1d)


**解説**：  
ヤコビアン det (**J**) が面積スケールを補正し、参照空間の要素を物理空間に変換します。

---

以下、物理空間上の二重積分から参照空間上でのガウス求積公式への展開を，ステップ・バイ・ステップで Markdown 形式にまとめる。  

---

## 4.4 参照空間上への積分式

以上を用いて，積分 \(I\) は参照空間上に写像される：
```math
I
= \int_{x_1}^{x_2}\int_{y_1}^{y_2} f(x,y)\,\mathrm{d}y\,\mathrm{d}x
= \int_{-1}^{1}\int_{-1}^{1} f\bigl(\mathbf{F}(\xi,\eta)\bigr)\,|\det J|\,\mathrm{d}\eta\,\mathrm{d}\xi.
```

---

## 4.5 1次元ガウス求積法の適用

- 1次元ガウス–ルジャンドル求積法（\(n\) 点）では，
  ```math
  \int_{-1}^{1} g(\xi)\,\mathrm{d}\xi
  \approx \sum_{i=1}^{n} w_i\,g(\xi_i),
  ```
  ただし \(\xi_i\) はガウス点，\(w_i\) は対応する重み。

- 二重積分の場合，\(\xi\) と \(\eta\) のそれぞれに同じ \(n\) 点ガウス求積を適用すると，
  ```math
  \int_{-1}^{1}\!\!\int_{-1}^{1} h(\xi,\eta)\,\mathrm{d}\eta\,\mathrm{d}\xi
  \approx
  \sum_{i=1}^{n}\sum_{j=1}^{n}
    w_i\,w_j\,
    h(\xi_i,\eta_j).
  ```

---

## 4.6  最終的なガウス求積公式

参照空間上の積分式に上記を適用すると，
```math
I
\approx
\sum_{i=1}^{n}\sum_{j=1}^{n}
w_i\,w_j\,|\det J|\,
f\bigl(\mathbf{F}(\xi_i,\eta_j)\bigr).
```

以上が，元の二重積分から参照空間上のガウス求積公式への導出過程である。

---

# 4章 │ Python 実装テンプレート（2変数対応・任意区間）

以下のテンプレートは任意の長方形区間 `[a,b]×[c,d]` での 2変数ガウス–ルジャンドル求積を実装する雛形です。
空欄を埋めて完成させ、理論式との対応を確認してください。

```python
import numpy as np

# === Gauss-Legendre データ: n 点数 → (ガウス点リスト, 重みリスト) ===
gauss_data = {
    2: ([-0.577350269189626,  0.577350269189626], [1.0, 1.0]),
    3: ([-0.774596669241483,  0.0,  0.774596669241483],
        [0.555555555555556, 0.888888888888889, 0.555555555555556]),
    4: ([-0.861136311594053, -0.339981043584856,
          0.339981043584856,  0.861136311594053],
        [0.347854845137454, 0.652145154862546,
         0.652145154862546, 0.347854845137454]),
    5: ([-0.906179845938664, -0.538469310105683, 0.0,
          0.538469310105683,  0.906179845938664],
        [0.236926885056189, 0.478628670499366, 0.568888888888889,
         0.478628670499366, 0.236926885056189]),
}

def gauss_legendre(n):
    """
    ガウス点と重みを返す（n=2～5）
    """
    if n not in gauss_data:
        raise ValueError(f"サポート外の n={n} です (2～5)")
    xg, wg = gauss_data[n]
    return np.array(xg), np.array(wg)


def two_dim_gauss(f, a, b, c, d, n):
    """
    [a,b]×[c,d] の長方形領域で n×n ガウス求積を行う。
    対応する理論式:
      1) 変数変換 : x = (b+a)/2 + (b−a)/2 * ξ_i
      2) 変数変換 : y = (d+c)/2 + (d−c)/2 * η_j
      3) 加重和   : Σ_i Σ_j w_i w_j f(x,y)
      4) ヤコビアン  : detJ = (b−a)(d−c)/4 の乗算

    ★★ 以下を埋めて実装を完成させよ ★★
    """
    # 1) 1次元ノードと重み取得
    xi, wi = gauss_legendre(n)
    eta, wj = xi, wi

    # 2) ヤコビアン 
    detJ = ...  # TODO

    I = 0.0
    # 3) 二重ループで加重和 
    for i in range(n):
        # 3-1) x 変数変換 
        x = ...  # TODO: 
        for j in range(n)
            # 3-2) y 変数変換 
            y = ...  # TODO
            # 3-3) 項の加算
            I += ...  # TODO

    # 4) 出力 (式 4.4)
    return ...  # TODO: detJ * I

if __name__ == "__main__":
    # 演習問題とその計算結果を表示
    print("問題 1: ∬_{[-1,1]^2} (x^2 + y^2) dA")
    f1 = lambda x, y: x**2 + y**2
    n1 = 2
    approx = two_dim_gauss(f1, -1, 1, -1, 1, n1)
    print(f"  n={n1}: {approx:.6f}")
    print("  理論値: 8/3 ≈ 2.666667")
    if abs(approx - 8/3) > 1e-6:
        print(f"  警告: n={n1} の近似値と理論値の差異が 1e-6 より大きい: {abs(approx - 8/3)}")
    else:
        print("問題1：成功")

    print("\n問題 2: ∬_{[0,1]×[0,2]} e^(x+y) dA")
    f2 = lambda x, y: np.exp(x + y)
    n2 = 2
    approx2 = two_dim_gauss(f2, 0, 1, 0, 2, n2)
    print(f"  n={n2}: {approx2:.6f}")
    print(f"  理論値: (e^2 - 1)(e - 1) ≈ {(np.e**2 - 1)*(np.e - 1):.6f}")
    if abs(approx2 - (np.e**2 - 1)*(np.e - 1)) > 1e-6:
        print(f"  警告: n={n2} の近似値と理論値の差異が 1e-6 より大きい: {abs(approx2 - (np.e**2 - 1)*(np.e - 1))}")
    else:
        print("問題2：成功")

    print("\n問題 3: ∬_{[1,2]×[0,1]} x*y dA")
    f3 = lambda x, y: x * y
    n3 = 2
    approx3 = two_dim_gauss(f3, 1, 2, 0, 1, n3)
    print(f"  n={n3}: {approx3:.6f}")
    print("  理論値: 3/4 = 0.75")
    if abs(approx3 - 3/4) > 1e-6:
        print(f"  警告: n={n3} の近似値と理論値の差異が 1e-6 より大きい: {abs(approx3 - 3/4)}")
    else:
        print("問題3：成功")
```

> **埋め方ガイド**
>
> 1. `detJ` にヤコビアンを設定: `(b - a) * (d - c) / 4`
> 2. `x` には `(b + a)/2 + (b - a)/2 * xi[i]`
> 3. `y` には `(d + c)/2 + (d - c)/2 * eta[j]`
> 4. `I +=` の部分に `wi[i] * wj[j] * f(x, y)` を記述
> 5. 関数の戻り値は `detJ * I`

---

